

General Guidelines

Package Management: Use pnpm exclusively for package management.
Typescript Best Practices:

Follow strict type safety.
Use zod for schema validation, including API responses, form validation, and query parameters.
Prefer readonly types wherever applicable.
Avoid any; use unknown or zod where necessary.
Ensure all code is strongly typed and avoids type assertions (as).
Use the null coalescing operator (??) and optional chaining (?.) to handle undefined values.



Functional Programming

Use immutable values wherever possible. Utilize libraries like immer for mutative operations while maintaining immutability.
Adopt pure functions, and remember that local mutation within a function is acceptable.
Almost always make types and arrays readonly.



React Best Practices

Component Architecture:

Organize files and folders by feature/domain rather than by type.
Use @tanstack/react-router for managing routes, leveraging loaders, and actions for data fetching and mutation.
Use Suspense and Error Boundaries strategically. Use react-error-boundary for handling runtime errors and react-error-overlay for development.
Always colocate state management and logic with components or features to reduce unnecessary prop drilling.
State Management:

Prefer @tanstack/react-query for managing server state, handling queries and mutations, and avoiding redundant local state.
Use optimistic updates with @tanstack/react-query when appropriate.
Avoid useEffect for synchronizing state; prefer loaders/actions or useSignal.
Retain transient view state in local component state where appropriate.
Forms:

Use @tanstack/form for form state management, validation, and submission handling.
Always validate form data using zod schemas.
Prefer HTML form elements for API mutations wherever possible.



Server State Management

Centralize query definitions passed to @tanstack/react-query to ensure consistency.
Use @tanstack/react-router's loader and action for cohesive query and mutation management.
Invalidate queries affected by mutations efficiently.
Avoid fetching data at the top level unless necessary to prevent waterfalls. Use nested loaders/actions or colocate queries.
Leverage pagination with @tanstack/react-query instead of infinite scrolling for better performance.



React Performance

Split components by state to avoid unnecessary re-renders.
Use useMemo for expensive computations and useEvent for stable callbacks.
For large lists, use virtualized lists with lazy loading.
Employ useTransition or useDeferredEvent to manage transitions and avoid UI flickering.



External Systems and Validation

Use zod for:

Validating API call responses.
Parsing pathnames, search params, and local storage.
Validating forms through @tanstack/form.



CSS Practices

Minimize margin usage; prefer gap in flexbox and grid layouts.
Use semantic HTML and accessible libraries for common UI elements like forms, date pickers, and dialogs.
Avoid inlining SVGs or using PNG files.
Use conditional styling utilities like clsx and create reusable components with tools like cva.



Playwright Guidelines

Use locator.fill instead of locator.type.
Always use locators for element interaction.
Generate robust locators during test development.
Leverage web-first assertions for reliable tests.

